//////////////////////////////////////////////////

//================ EXT. STL ================
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;

/* ordered set*/ (multi)
template <class T, class cmp = less_equal<T>> using ordered_set = tree<T, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;
// s.erase(s.upper_bound(value))

/* ordered map*/
template <class key, class value, class cmp = less_equal<key>> using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;
// find_by_order(k)  returns iterator to kth element starting from 0;
// order_of_key(k) returns count of elements strictly smaller than k;

template <typename T> using PQ = priority_queue<T>;
template <typename T> using QP = priority_queue<T,vector<T>,greater<T>>;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;// ordered_set<ll> st;st.order_of_key(x) // number of elements < x ; *(st.find_by_order(x))  (x)th largest element
template <typename T> using ordered_multiset = tree<T, null_type,less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;
template <typename T,typename R> using ordered_map = tree<T, R , less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T,typename R> using ordered_multimap = tree<T, R , less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;

//////////////////////////////////////////////////

memset(vcetor/array, 0/1, sizeof(vector/array));
* a+b = a^b + 2*a&b;
* a+b = a|b + a&b;
* OR/AND/XOR are associative and commutative.
* A ^ 0 = A 
* if A^B = C, then A^C = B
"#define getunique(v){sort(v.begin(), v.end());v.erase(unique(v.begin(), v.end()), v.end());}",
* https://oeis.org/ Sequence Related Problem Analysis

//////////////////////////////////////////////////

manually lower bound and upper bound:
 
int lower_bound(vector<int>& arr, int N, int val)
{
    ll mid, low = 0, high = N;
    while (low < high) {
        mid = low + (high - low) / 2;
        if (val <= arr[mid])
            high = mid;
        else
            low = mid + 1;
    }
    // if val is greater than arr[n-1]
    if(low < N && arr[low] < val) low++;
    return low;
}
 
int upper_bound(vector<int>& arr, int N, int val)
{
    ll mid, low = 0, high = N;
    while (low < high) {
        mid = low + (high - low) / 2;
        if (val >= arr[mid]) 
            low = mid + 1;
        else
            high = mid;
    }
    if(low < N && arr[low] <= val) low++; 
    return low;
}

//////////////////////////////////////////////////

Lamda function:
auto function_name = [&](parameters) -> data_type
{
    function body;
};

//////////////////////////////////////////////////

bool cmp(const pair<int,int> & p1,const pair<int,int> & p2)
{
    if(p1.ss>p2.ss) return 1;
    return 0;
}

//============================================== Bits
#define Set(x, k) (x |= (1LL << k))
#define Unset(x, k) (x &= ~(1LL << k))
#define Check(x, k) (x & (1LL << k))
#define Toggle(x, k) (x ^= (1LL << k))
int popcount(ll x){return __builtin_popcountll(x);};
int poplow(ll x){return __builtin_ctzll(x);};
int pophigh(ll x){return 63 - __builtin_clzll(x);};
//>>Convert
string decToBinary(int n){string s="";int i = 0;while (n > 0) {s =to_string(n % 2)+s;n = n / 2;i++;}return s;}
ll binaryToDecimal(string n){
    string num = n;ll dec_value = 0;
    int base = 1;int len = num.length();
    for(int i = len - 1; i >= 0; i--){
        if (num[i] == '1')dec_value += base;
        base = base * 2;
    }
    return dec_value;
}
//==============================================

//////////////////////////////////////////////////

long long pow(long long base, long long exp, long long mod) {
    long long result = 1;
    base = base % mod;  // Ensure base is in mod
 
    while (exp > 0) {
        // If exp is odd, multiply base with the result
        if (exp % 2 == 1)
            result = (result * base) % mod;
 
        // Now exp must be even, so divide it by 2
        exp = exp >> 1;
        base = (base * base) % mod;  // Square the base
    }
 
    return result;
}

int mod_mul(int a, int b, int m) {
    return (a % m * b % m) % m;
}

ll mod_pow(ll a, ll b, ll m) {
    ll res = 1; 
    while (b > 0) {
        if (b & 1) res = (res * a) % m;
        a = (a * a) % m; 
        b >>= 1;
    }
    return res;
}

// inverse mod, this is fermat's little theorem
int mod_inv(int n, int m){
    return mod_pow(n, m-2, m);
}

int mod_div(int a,int b,int m){
    return mod_mul(a, mod_inv(b, m), m);
}

//////////////////////////////////////////////////

long long nCr(int n, int r){
    if(r>n || r<0) return 0;
    if(r==n || r==0) return 1;
    ll sum = 1LL;
    for(int i = 1; i <= r; i++){
        sum = (sum * (n - r + i) / i) % mod;
    }
    return sum % mod;
}

other process: and more accurate:
vetor<int> fact(n);
/* in the main function
    fact[0] = 1;
    for(int i=1; i<=n; i++) fact[i] = mod_mul(fact[i-1],i,m);
*/
int ncr(int n, int r) {
    if(r<0 || r>n) return 0;
    return mod_inv(fact[n],mod_mul(fact[r],fact[n-r],m),m);
}
//////////////////////////////////////////////////

bool isP(int n)
{
    if(n==2 || n==3)return true;
    else if(n<=1 || n%2==0 || n%3==0)return false;
    for(int i=5;i*i<=n;i+=6)
    {
        if(n%i==0 || n%(i+2)==0)return false;
    }
    return true;
}

/*--------------- Seive -----------------------*/
//////////////////////////////////////////////////

bool pr[N];
vector<int> prime;
void sieve(ll n)
{
    memset(pr,true ,sizeof(pr));
    for(ll p=2;p*p<=n;p++)
    {
        if(pr[p]==1)
        {
            for(int i=p*p;i<=n;i+=p)
            {
                pr[i]=false;
            }
        }
    }
   for(int i=2;i<=n;i++) if(pr[i]==true) prime.push_back(i);
}
//////////////////////////////////////////////////

vector<int>spf(100001,-1);
void fillSpf(){
    for(int i = 2; i <= 100000; i++){
        if(spf[i] == -1){
            for(int j = i*i; j <= 100000; j+= i)  {
                if (spf[j] == -1)    spf[j] = i;
            }
        }
    }
}

////////////////////////////////////////////////////
// Get All The Divisors Of That Number
vector<int> getdiv(int n)
{
    vector<int> ans;
    for (int i = 1; i * i <= n; i++)
    {
        if (n % i == 0)
        {
            ans.pb(i);
            if (n / i != i)
                ans.pb(n / i);
        }
    }
    return ans;
}

////////////////////////////////////////////////////
// to get the prime factors of that number
vector<int> getprimefac(int n)
{
    vector<int> ans;
    int nn = n;
    for (int i = 2; i * i <= n; i++)
    {
        if (nn % i == 0)
        {
            ans.pb(i);
            while (nn % i == 0)
            {
                nn /= i;
            }
        }
    }
    if (nn > 1)
    {
        ans.pb(nn);
    }
    return ans;
}

***************** Graph functions *****************

////////////////////////////////////////////////////

void bfs(vector<vector<int>>& adj, int s) 
{
    queue<int> q;  
    vector<int> level(adj.size(),0);
    vector<bool> visited(adj.size(), false);
    visited[s] = true;
    q.push(s);
    level[s] = 0;
    while (!q.empty()) {
        int curr = q.front();
        q.pop();
        cout << curr << " " << level[curr] << endl;
        for (int x : adj[curr]) {
            if (!visited[x]) {
                visited[x] = true;
                level[x] = level[curr]+1;
                q.push(x);
            }
        }
    }
}

////////////////////////////////////////////////////

void DFS(vector<vector<int>> &adj, vector<bool> &visited, int s){
  	static int time = 0;
    visited[s] = true;
    time = time +1;
	start[s] = time;
    cout << s << " - " << "sart time: " << time << endl;
    for (int i : adj[s]) {
        if (visited[i] == false)
            DFS(adj, visited, i);
    }
  time = time +1;
  finish[s] = time;
  cout << s << " - " << "finish time: " << time << endl;
}

////////////////////////////////////////////////////

void dijkstra(vector<pair<int,int>> adj[], int s, int n) {
    vector<int> dist(n,INT_MAX);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int> >> pq;
    pq.push({0,s});
    dist[s]=0;
    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        for (auto &x : adj[u]) {
            int v = x.first;
            int weight = x.second;
            if (dist[v] > dist[u] + weight) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
    for(auto& it: dist) cout << it << ' ';
    cout << endl;
}

////////////////////////////////////////////////////
************** Bellman Ford ****************

struct bf {
    int u,v,w;
};

void bellman(vector<bf>& arr, int s, int n, int m) {
    vector<int> dist(n,INT_MAX);
    dist[s] = 0;
    for(int i=0; i<n-1; i++) {
        for(int j=0; j<m; j++) {
            int u = arr[j].u;
            int v = arr[j].v;
            int w = arr[j].w;
            if(dist[u] != INT_MAX && dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
            }
        }
    }
    for(int j=0; j<m; j++) {
        int u = arr[j].u;
        int v = arr[j].v;
        int w = arr[j].w;
        if(dist[u] != INT_MAX && dist[v] > dist[u] + w) {
            dist[v] = dist[u] + w;
            cout << "Graph contains negative weight cycle" << endl;
            return;
        }
    }
    for(int j=0; j<n; j++) {
        cout << "Vertex " << j+1 << " \tDistance from source " << s << " is " << dist[j] << endl;
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<bf> arr(m);
    for(int i=0; i<m; i++) {
        cin >> arr[i].u >> arr[i].v >> arr[i].w;
    }
    int s;  // s = sourch
    cin >> s;
    bellman(arr, s, n, m);
    return 0;
}

////////////////////////////////////////////////////

void floyed_warshel(vector<vector<int>>& arr) { // arr adjacency matrix
    for(int k=0; k<n; k++) {
        for(int i=0; i<n; i++) {
            for(int j=0; j<n; j++) {
                if(arr[i][k] != INT_MAX && arr[k][j]!= INT_MAX && arr[i][j] > arr[i][k] + arr[k][j]) 
                    arr[i][j] = arr[i][k] + arr[k][j];
            }

        }
    }
    for(int i=0; i<n; i++) {
        for(int j=0; j<n; j++) {
            if(arr[i][j] == INT_MAX) cout << "INF ";
            else
                cout << arr[i][j] << " ";   
        }
        cout << endl;
    }
}

////////////////////////////////////////////////////
************** Kosaraju's Algorithm or SCC **************

// Function to perform DFS and store vertices according to their finish times
void dfs1(int node, vector<vector<int>>& adj, vector<bool>& visited, stack<int>& finishStack) {
    visited[node] = true;
    for (int v : adj[node]) {
        if (!visited[v]) {
            dfs1(v, adj, visited, finishStack);
        }
    }
    finishStack.push(node); // Store the node after all its adjacent nodes are visited
}

// Function to perform DFS on the reversed graph and mark visited SCCs
void dfs2(int node, vector<vector<int>>& transposeAdj, vector<bool>& visited) {
    cout << node << " "; // Print node part of the current SCC
    visited[node] = true;
    for (int v : transposeAdj[node]) {
        if (!visited[v]) {
            dfs2(v, transposeAdj, visited);
        }
    }
}

// Kosaraju's Algorithm to find all SCCs
void kosarajuSCC(int V, vector<vector<int>>& adj) {
    vector<bool> visited(V, false);
    stack<int> finishStack;

    // Step 1: Perform DFS and store vertices in finishStack by finish time
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            dfs1(i, adj, visited, finishStack);
        }
    }

    // Step 2: Transpose the graph (reverse all edges)
    vector<vector<int>> transposeAdj(V);
    for (int u = 0; u < V; u++) {
        for (int v : adj[u]) {
            transposeAdj[v].push_back(u); // Reverse the edge u -> v to v -> u
        }
    }

    // Step 3: Perform DFS on the transposed graph in the order of finishStack
    fill(visited.begin(), visited.end(), false); // Reset visited for second DFS pass
    cout << "Strongly Connected Components (SCCs):" << endl;
    while (!finishStack.empty()) {
        int node = finishStack.top();
        finishStack.pop();
        if (!visited[node]) {
            // DFS to print the current SCC
            dfs2(node, transposeAdj, visited);
            cout << endl;
        }
    }
}

////////////////////////////////////////////////////
***************** Kahn's Algorithm ****************
// Function to perform topological sort using Kahn's Algorithm

void topologicalSortKahns(int V, vector<vector<int>>& adj) {
    vector<int> inDegree(V, 0);
    
    // Calculate in-degrees of all vertices
    for (int u = 0; u < V; u++) {
        for (int v : adj[u]) {
            inDegree[v]++;
        }
    }

    // Queue to store vertices with in-degree 0
    queue<int> q;
    for (int i = 0; i < V; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    vector<int> topoSort;
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        topoSort.push_back(node);

        // Reduce in-degree for adjacent vertices and push to queue if in-degree becomes 0
        for (int v : adj[node]) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                q.push(v);
            }
        }
    }

    // Check if a valid topological sort exists
    if (topoSort.size() != V) {
        cout << "Cycle detected, topological sort not possible" << endl;
    } else {
        cout << "Topological Sort (Kahn's Algorithm): ";
        for (int node : topoSort) {
            cout << node << " ";
        }
        cout << endl;
    }
}

///////////////////////////////////////////////////////////

======================= Disjoint set =======================
// directly can say whether the node is connected to the other node.

class DisjointSet {
public:
    vector<int> size, parent;
    DisjointSet(int n) {
        parent.resize(n+1, 0);
        size.resize(n+1);
        for(int i =0;i<=n;i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    int findUPar(int node) {
        if(node == parent[node]) return node;
        return parent[node] = findUPar(parent[node]);
    }
    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if(ulp_u == ulp_v) return;
        if(size(ulp_u) < size(ulp_v)) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};

======================= Dynamic Programming ========================

/////////////////////////// coin change /////////////////////////////

int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, INT_MAX);  // Create a DP array of size (amount + 1)
    dp[0] = 0;  // Base case: 0 coins are needed to make amount 0

    // Fill the DP array
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (i - coin >= 0 && dp[i - coin] != INT_MAX) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }

    // If dp[amount] is still INT_MAX, it means we can't make the amount
    return (dp[amount] == INT_MAX) ? -1 : dp[amount];
}